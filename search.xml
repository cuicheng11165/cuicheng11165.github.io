<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[正则表达式语法及常用正则]]></title>
      <url>http://simmon.club/2016/09/26/2016-09-26-Regex-Expression/</url>
      <content type="html"><![CDATA[<p>这一部分主要总结一些常用正则表达式的用法。</p>
<a id="more"></a>
<p>项目中常用正则表达式来进行校验，然而确实总是遗忘一些相关的语法，需要谷歌搜索一些不太好想或写的正则规则。所以在此总结一份。争取依靠个人总结不断更新这篇日志，节约之后 90% 的查阅搜索时间。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>正则表达式就是事先声明一组规则，用于匹配字符串中的字符。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">执行多行匹配。</td>
</tr>
</tbody>
</table>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>在正则表达式的模式中，有一些字符是有特殊含义的，被称为元字符。元字符都是针对单个字符匹配的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">查找单个字符，除了换行和行结束符。</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于[a-zA-Z0-9_]</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_]</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配任何空白字符，相当于 [ \f\n\r\t\v]</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">匹配任何非空白字符，相当于 [^\s]</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配任何 0 到 9 之间的单个数字，相当于 [0-9]</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9]</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配单词边界。</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:center">匹配非单词边界。</td>
</tr>
<tr>
<td style="text-align:center">\0</td>
<td style="text-align:center">查找 NUL 字符。</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">查找换行符。</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">查找换页符。</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">查找回车符。</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">查找制表符。</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">查找垂直制表符。</td>
</tr>
<tr>
<td style="text-align:center">\xxx</td>
<td style="text-align:center">查找以八进制数 xxx 规定的字符。</td>
</tr>
<tr>
<td style="text-align:center">\xdd</td>
<td style="text-align:center">查找以十六进制数 dd 规定的字符。</td>
</tr>
<tr>
<td style="text-align:center">[\u4e00-\u9fa5]</td>
<td style="text-align:center">匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 )</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配字符串的开头</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配字符串的结尾</td>
</tr>
</tbody>
</table>
<h3 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h3><p>方括号用于查找某个范围内的字符<br>| 表达式     |  描述  |<br>|:—–: | :—-:  |<br>|[…] | 匹配方括号中的所有字符|<br>|[^…]  | 匹配非方括号中的所有字符|</p>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">n*</td>
<td style="text-align:center">匹配任何包含零个或多个 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">n+</td>
<td style="text-align:center">匹配任何包含至少一个 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">n?</td>
<td style="text-align:center">匹配任何包含零个或一个 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">n{X}</td>
<td style="text-align:center">匹配包含 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td style="text-align:center">n{X,Y}</td>
<td style="text-align:center">匹配包含 X 或 Y 个 n 的序列的字符串。</td>
</tr>
<tr>
<td style="text-align:center">n{X,}</td>
<td style="text-align:center">匹配包含至少 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td style="text-align:center">n$</td>
<td style="text-align:center">匹配任何结尾为 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">^n</td>
<td style="text-align:center">匹配任何开头为 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">?=n</td>
<td style="text-align:center">匹配任何其后紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">?!n</td>
<td style="text-align:center">匹配任何其后没有紧接指定字符串 n 的字符串。</td>
</tr>
</tbody>
</table>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(exp)</td>
<td style="text-align:center">匹配 exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td style="text-align:center">(?<name>exp)</name></td>
<td style="text-align:center">匹配 exp,并捕获文本到名称为 name 的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td style="text-align:center">(?:exp)</td>
<td style="text-align:center">匹配 exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td style="text-align:center">(?=exp)</td>
<td style="text-align:center">正向先行断言——代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配 exp。</td>
</tr>
<tr>
<td style="text-align:center">(?!exp)</td>
<td style="text-align:center">负向先行断言——代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配 exp</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;=exp)</td>
<td style="text-align:center">正向后行断言,代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配 exp。</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;!exp)</td>
<td style="text-align:center">负向后行断言,代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配 exp。</td>
</tr>
<tr>
<td style="text-align:center">(?#comment)</td>
<td style="text-align:center">这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>
<h2 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h2><h3 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h3><ul>
<li><p>数字：<code>^[0-9]*$</code></p>
</li>
<li><p>n 位的数字：<code>^\d{n}$</code></p>
</li>
<li><p>至少 n 位的数字：<code>^\d{n,}$</code></p>
</li>
<li><p>m-n 位的数字：<code>^\d{m,n}$</code></p>
</li>
<li><p>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></p>
</li>
<li><p>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]{1,2})?$</code></p>
</li>
<li><p>带 1-2 位小数的正数或负数：<code>^(\-)?\d+(\.\d{1,2})?$</code></p>
</li>
<li><p>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></p>
</li>
<li><p>有两位小数的正实数：<code>^[0-9]+(.[0-9]{2})?$</code></p>
</li>
<li><p>有 1~3 位小数的正实数：<code>^[0-9]+(.[0-9]{1,3})?$</code></p>
</li>
<li><p>非零的正整数：<code>^[1-9]\d*$</code> 或 <code>^([1-9][0-9]*){1,3}$</code> 或 <code>^\+?[1-9][0-9]*$</code></p>
</li>
<li><p>非零的负整数：<code>^\-[1-9][]0-9&quot;*$</code> 或 <code>^-[1-9]\d*$</code></p>
</li>
<li><p>非负整数：<code>^\d+$</code> 或 <code>^[1-9]\d*|0$</code></p>
</li>
<li><p>非正整数：<code>^-[1-9]\d*|0$</code> 或 <code>^((-\d+)|(0+))$</code></p>
</li>
<li><p>非负浮点数：<code>^\d+(\.\d+)?$</code> 或 <code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code></p>
</li>
<li><p>非正浮点数：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code> 或 <code>^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code></p>
</li>
<li><p>正浮点数：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$</code> 或 <code>^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code></p>
</li>
<li><p>负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code> 或 <code>^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code></p>
</li>
<li><p>浮点数：<code>^(-?\d+)(\.\d+)?$</code> 或 <code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></p>
</li>
</ul>
<h3 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h3><ul>
<li><p>汉字：<code>^[\u4e00-\u9fa5]{0,}$</code></p>
</li>
<li><p>英文和数字：<code>^[A-Za-z0-9]+$</code> 或 <code>^[A-Za-z0-9]{4,40}$</code></p>
</li>
<li><p>长度为 3-20 的所有字符：<code>^.{3,20}$</code></p>
</li>
<li><p>由 26 个英文字母组成的字符串：<code>^[A-Za-z]+$</code></p>
</li>
<li><p>由 26 个大写英文字母组成的字符串：<code>^[A-Z]+$</code></p>
</li>
<li><p>由 26 个小写英文字母组成的字符串：<code>^[a-z]+$</code></p>
</li>
<li><p>由数字和 26 个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></p>
</li>
<li><p>由数字、26 个英文字母或者下划线组成的字符串：<code>^\w+$ 或 ^\w{3,20}$</code></p>
</li>
<li><p>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></p>
</li>
<li><p>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code> 或 <code>^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</code></p>
</li>
<li><p>可以输入含有 ^%&amp;’,;=?$\” 等字符：<code>[^%&amp;&#39;,;=?$\x22]+</code></p>
</li>
<li><p>禁止输入含有 ~ 的字符：<code>[^~\x22]+</code></p>
</li>
</ul>
<h3 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h3><ul>
<li><p>Email 地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></p>
</li>
<li><p>域名：<code>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</code></p>
</li>
<li><p>InternetURL：<code>[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></p>
</li>
<li><p>手机号码：<code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</code></p>
</li>
<li><p>电话号码（”XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX）：<code>^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$</code></p>
</li>
<li><p>国内电话号码（0511-4405222、021-87888822）：<code>\d{3}-\d{8}|\d{4}-\d{7}</code></p>
</li>
<li><p>身份证号（15 位、18 位数字）：<br>15 位： <code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$</code><br>18 位： <code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$</code></p>
</li>
<li><p>短身份证号码（数字、字母 x 结尾）：<code>^([0-9]){7,18}(x|X)?$</code> 或 <code>^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</code></p>
</li>
<li><p>帐号是否合法（字母开头，允许 5-16 字节，允许字母数字下划线）：<code>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</code></p>
</li>
<li><p>密码（以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线）：<code>^[a-zA-Z]\w{5,17}$</code></p>
</li>
<li><p>强密码（必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间）：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></p>
</li>
<li><p>日期格式：<code>^\d{4}-\d{1,2}-\d{1,2}</code></p>
</li>
<li><p>一年的 12 个月（01～09 和 1～12）：<code>^(0?[1-9]|1[0-2])$</code></p>
</li>
<li><p>一个月的 31 天（01～09 和 1～31）：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></p>
</li>
<li><p>xml 文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></p>
</li>
<li><p>双字节字符：<code>[^\x00-\xff]</code> （包括汉字在内，可以用来计算字符串的长度（一个双字节字符长度计 2，ASCII字符计 1））</p>
</li>
<li><p>空白行的正则表达式：<code>\n\s*\r</code> （可以用来删除空白行）</p>
</li>
<li><p>HTML 标记的正则表达式：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code> （网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力）</p>
</li>
<li><p>首尾空白字符的正则表达式：<code>^\s*|\s*$或(^\s*)|(\s*$)</code> （可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等），非常有用的表达式）</p>
</li>
<li><p>校验金额（2位小数）： <code>^[0-9]+(.[0-9]{2})?$</code></p>
</li>
<li><p>腾讯 QQ 号：<code>[1-9][0-9]{4,}</code> （腾讯 QQ 号从 10000 开始）</p>
</li>
<li><p>中国邮政编码：<code>[1-9]\d{5}(?!\d)</code> （中国邮政编码为 6 位数字）</p>
</li>
<li><p>IP 地址：<code>\d+\.\d+\.\d+\.\d+</code> （提取IP地址时有用）</p>
</li>
<li><p>IP 地址：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></p>
</li>
<li><p>IPV6 地址： <code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></p>
</li>
<li><p>URL 链接： <code>((http|ftp|https)://)(([a-zA-Z0-9\._-]+\.[a-zA-Z]{2,6})|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(:[0-9]{1,4})*(/[a-zA-Z0-9\&amp;%_\./-~-]*)?</code></p>
</li>
<li><p>EMOJI 表情: <code>([\uE000-\uF8FF]|\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF])</code></p>
</li>
<li><p>检查 IE 版本 <code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</code></p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>这里的一篇图灵文章可以帮助你了解正则表达式的更深层原理:<a href="http://www.ituring.com.cn/tupubarticle/5512" target="_blank" rel="external">模式、自动机和正则表达式</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vim命令]]></title>
      <url>http://simmon.club/2016/08/02/2016-08-02-vim/</url>
      <content type="html"><![CDATA[<p>这一部分主要介绍vim常用用法。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vim（Vi[Improved]）编辑器是功能强大的跨平台文本文件编辑工具，继承自Unix系统的Vi编辑器，支持Linux/Mac OS X/Windows系统，利用它可以建立、修改文本文件。进入Vim编辑程序，可以在终端输入下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim [filename]</div></pre></td></tr></table></figure></p>
<p>其中filename是要编辑器的文件的路径名。如果文件不存在，它将为你建立一个新文件。Vim编辑程序有三种操作模式，分别称为<strong>普通模式</strong>、<strong>插入模式</strong> 、 <strong>命令模式</strong> 和 <strong>可视模式</strong>，当运行Vim时，首先进入普通模式。</p>
<h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">k                上移；</div><div class="line">j                下移；</div><div class="line">h                左移；</div><div class="line">l                右移；</div><div class="line">ctrl+f        	 在文件中前移一页（相当于 page down）；</div><div class="line">ctrl+b           在文件中后移一页（相当于 page up）；</div><div class="line">*                当光标停留在一个单词上，该键会在文件内搜索该单词，并跳转到下一处；</div><div class="line">#                当光标停留在一个单词上，该键在文件内搜索该单词，并跳转到上一处；</div><div class="line">gg               将光标定位到文件第一行起始位置；</div><div class="line">G                将光标定位到文件最后一行起始位置；</div><div class="line">NG/Ngg           将光标定位到第 N 行的起始位置。</div><div class="line">H                将光标移到屏幕上的起始行（或最上行）；</div><div class="line">M                将光标移到屏幕中间；</div><div class="line">L                将光标移到屏幕最后一行;</div><div class="line">w                右移光标到下一个字的开头；</div><div class="line">e                右移光标到一个字的末尾；</div><div class="line">b                左移光标到前一个字的开头；</div><div class="line">0                数字０，左移光标到本行的开始；</div><div class="line">$                右移光标，到本行的末尾；</div><div class="line">^                移动光标，到本行的第一个非空字符。</div></pre></td></tr></table></figure>
<h3 id="搜索匹配"><a href="#搜索匹配" class="headerlink" title="搜索匹配"></a>搜索匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/str1            正向搜索字符串 str1；</div><div class="line">n                继续搜索，找出 str1 字符串下次出现的位置；</div><div class="line">N                继续搜索，找出 str1 字符串上一次出现的位置；</div><div class="line">?str2            反向搜索字符串 str2 。</div></pre></td></tr></table></figure>
<p>搜索时忽略大小写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:set ignorecase  忽略大小写</div><div class="line">:set noignorecase大小写敏感</div><div class="line">/\cstr1          忽略大小写</div><div class="line">/\Cstr1          大小写敏感</div></pre></td></tr></table></figure></p>
<h3 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x                删除光标所指向的当前字符；</div><div class="line">dw               删除光标右侧的字；</div><div class="line">db               删除光标左侧的字；</div><div class="line">dd               删除光标所在行，并去除空隙；</div><div class="line">ndd              删除（剪切） n 行内容，并去除空隙；</div><div class="line">d$               从当前光标起删除字符直到行的结束；</div><div class="line">d0               从当前光标起删除字符直到行的开始；</div><div class="line">J                删除本行的回车符（CR），并和下一行合并；</div><div class="line">s                用输入的正文替换光标所指向的字符；</div><div class="line">S                删除当前行，并进入插入模式；</div><div class="line">c$               用输入的正文替换从光标开始到本行末尾的所有字符；</div><div class="line">c0               用输入的正文替换从本行开头到光标的所有字符。</div></pre></td></tr></table></figure>
<h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p                小写字母 p，将缓冲区的内容粘贴到光标的后面；</div><div class="line">P                大写字母 P，将缓冲区的内容粘贴到光标的前面；</div><div class="line">yy               复制当前行到内存缓冲区；</div><div class="line">nyy              复制 n 行内容到内存缓冲区；</div></pre></td></tr></table></figure>
<h3 id="撤销和重复"><a href="#撤销和重复" class="headerlink" title="撤销和重复"></a>撤销和重复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">u                撤消前一条命令的结果；</div><div class="line">.                重复最后一条修改正文的命令。</div></pre></td></tr></table></figure>
<h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">i            	 在光标左侧插入正文;</div><div class="line">a            	 在光标右侧插入正文;</div><div class="line">o            	 在光标所在行的下一行增添新行;</div><div class="line">O            	 在行的上一行增添新行;</div><div class="line">I            	 在行的开头插入;</div><div class="line">A            	 在行的末尾插入。</div></pre></td></tr></table></figure>
<h3 id="退出插入模式"><a href="#退出插入模式" class="headerlink" title="退出插入模式"></a>退出插入模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ESC </div><div class="line">Ctrl+[</div></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="打开、保存、退出"><a href="#打开、保存、退出" class="headerlink" title="打开、保存、退出"></a>打开、保存、退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">:e file_temp	 在已经启动的Vim中打开一个文件;</div><div class="line">:q               在未作修改的情况下退出；</div><div class="line">:q!              放弃所有修改，退出编辑程序；</div><div class="line">:w               保存；</div><div class="line">:w file_temp	 将当前文件另存为 file_temp。</div></pre></td></tr></table></figure>
<h3 id="行号与文件"><a href="#行号与文件" class="headerlink" title="行号与文件"></a>行号与文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:n               将光标移到第 n 行</div></pre></td></tr></table></figure>
<h3 id="恢复文件"><a href="#恢复文件" class="headerlink" title="恢复文件"></a>恢复文件</h3><p>Vim 在编辑某个文件时，会另外生成一个临时文件，这个文件的名称通常以 . 开头，并以 .swp 结尾。Vim 在正常退出时，该文件被删除，若意外退出，而没有保存文件的最新修改内容，则可以使用恢复命令 :recover 来恢复文件，也可以在启动Vim时用 -r 选项。</p>
<h3 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">autoindent       设置该选项，则正文自动缩进;</div><div class="line">ignorecase       设置该选项，则忽略规则表达式中大小写字母的区别;</div><div class="line">number           设置该选项，则显示正文行号;</div><div class="line">ruler            设置该选项，则在屏幕底部显示光标所在行、列的位置;</div><div class="line">tabstop          设置按 Tab 键跳过的空格数。例如 :set tabstop=n，n 默认值为 8。</div></pre></td></tr></table></figure>
<h3 id="Shell切换"><a href="#Shell切换" class="headerlink" title="Shell切换"></a>Shell切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:!shell_command 执行完 shell_command 后回到Vim</div></pre></td></tr></table></figure>
<h2 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">v               进入,一个字符一个字符地选;</div><div class="line">V               进入，一行一行地选;</div><div class="line">ctrl-v          进入，选中屏幕上的一个矩形区域;</div><div class="line">d               删除所选中的部分;</div><div class="line">D               删除所选中部分所在的行;</div><div class="line">y               复制选中的部分;</div><div class="line">Y               复制选中部分所在的行;</div><div class="line">&gt;               所选中的部分都缩进一个tab;</div><div class="line">=               在所选中的部分删除一个tab的缩进;</div><div class="line">c               会把选中的内容删除并进入插入模式;</div><div class="line">C               会直接删除选中的内容所在的行并进入插入模式。</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vmware vSphere虚拟机与主机共享剪贴板]]></title>
      <url>http://simmon.club/2016/07/12/2016-07-12-vmvare-vsphere-share-plate/</url>
      <content type="html"><![CDATA[<p>默认情况下，Vmware vSphere已禁用针对ESXESXi的复制和粘贴操作，以防止公开已复制到剪贴板中的敏感数据。其实可以通过设置启用它，具体操作如下：</p>
<a id="more"></a>
<ol>
<li><p>使用 vSphere Client 登录到 vCenter Server 系统并选择虚拟机，虚拟机要在关闭状态下。</p>
</li>
<li><p>选中虚拟机，单击右键编辑设置。</p>
</li>
<li><p>选择选项 &gt; 高级 &gt; 常规，然后单击配置参数。</p>
</li>
<li><p>单击添加行，并在“名称”和“值”列中键入以下值。名称值</p>
<pre><code>isolation.tools.copy.disable     false
isolation.tools.paste.disable    false
</code></pre></li>
<li><p>单击确定以关闭“配置参数”对话框，然后再次单击确定以关闭“虚拟机属性”对话框。</p>
</li>
<li><p>重新启动虚拟机。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用p4merge解决git冲突问题]]></title>
      <url>http://simmon.club/2016/07/12/2016-07-12-git-p4merge/</url>
      <content type="html"><![CDATA[<p>git在遇到冲突的时候除了可以直接编辑文件来解决冲突，也可以借助一些第三方的图形化工具来解决。p4merge是p4v上采用的一种比对工具，本文采用p4merge来解决git冲突，平台是Linux Mint17。</p>
<a id="more"></a>
<h2 id="p4merge安装"><a href="#p4merge安装" class="headerlink" title="p4merge安装"></a>p4merge安装</h2><p><strong>如果linux系统上面已经安装过p4v客户端，p4merge应该已经装好了，就可以跳过p4merge安装这个步骤了。</strong></p>
<ol>
<li><p>到官网下载p4merge,选择linux平台进行下载</p>
<p> <a href="https://www.perforce.com/downloads/integrations" target="_blank" rel="external">https://www.perforce.com/downloads/integrations</a></p>
</li>
<li><p>解压下载的p4merge软件包</p>
<pre><code>tar -zxvf p4v.tgz
</code></pre></li>
<li><p>解压之后进入解压出来的文件夹，发现里面会有两个子文件夹bin和lib,将这两个文件夹中的文件分别拷贝到对应的系统目录下，执行以下指令即可：</p>
<pre><code>sudo cp -rf bin/* /usr/local/bin/
sudo cp -rf lib/* /usr/local/lib/
</code></pre></li>
<li><p>这个时候p4merge应该就可以使用了，在控制台输入p4merge应该就会出现diff和merge对话框。下面将会修改git的配置文件来使用p4merge.</p>
</li>
</ol>
<h2 id="配置-gitconfig"><a href="#配置-gitconfig" class="headerlink" title="配置.gitconfig"></a>配置.gitconfig</h2><p>打开.gitconfig:</p>
<pre><code>vim ~/.gitconfig
</code></pre><p>向其中添加以下内容：</p>
<pre><code>[diff]
    tool = p4merge
[difftool]
    prompt = false
[merge]
    tool = p4merge
[mergetool]
    prompt = false
</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>查看diff</p>
<pre><code>git difftool
</code></pre><p>解决冲突</p>
<pre><code>git mergetool
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数字签名是什么？]]></title>
      <url>http://simmon.club/2016/07/04/2016-07-04-digital-signature-and-digital%20certificate/</url>
      <content type="html"><![CDATA[<p>今天，我读到一篇好文章。<br>它用图片通俗易懂地解释了，”数字签名”（digital signature）和”数字证书”（digital certificate）到底是什么。我对这些问题的理解，一直是模模糊糊的，很多细节搞不清楚。读完这篇文章后，发现思路一下子就理清了。</p>
<a id="more"></a>
<hr>
<p>原文网址：<a href="http://www.youdzone.com/signature.html" target="_blank" rel="external">http://www.youdzone.com/signature.html</a><br>转载网址：<a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a> </p>
<p> 1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080901.png" alt=""></p>
<p> 2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080902.png" alt=""></p>
<p> 3.苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080903.png" alt=""></p>
<p> 4.鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080904.png" alt=""></p>
<p> 5.鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080905.png" alt=""></p>
<p> 6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080906.png" alt=""></p>
<p> 7.鲍勃将这个签名，附在信件下面，一起发给苏珊。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080907.png" alt=""></p>
<p> 8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080908.png" alt=""></p>
<p> 9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080909.png" alt=""></p>
<p> 10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080910.png" alt=""></p>
<p> 11.后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080911.png" alt=""></p>
<p> 12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080912.png" alt=""></p>
<p> 13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080913.png" alt=""></p>
<p> 14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080914.jpg" alt=""></p>
<p> 15.首先，客户端向服务器发出加密请求。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080915.png" alt=""></p>
<p> 16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080916.png" alt=""></p>
<p> 17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080917.png" alt=""></p>
<p> 18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080918.png" alt=""></p>
<p> 19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080919.jpg" alt=""></p>
<p> 20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。</p>
<p><img src="http://image.beekka.com/blog/201108/bg2011080920.png" alt=""></p>
<p>（完）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VSC Keyboard Shortcuts]]></title>
      <url>http://simmon.club/2016/06/30/2016-06-30-Visual-Stdio-Code/</url>
      <content type="html"><![CDATA[<p>Some frequently used vsc keyboard shortcuts.</p>
<a id="more"></a>
<ul>
<li>shift+ctrl+A 注释代码块</li>
<li>ctrl+/       注释</li>
</ul>
<ul>
<li>shift+ctrl+alt+[ 整个文件函数折叠</li>
<li>shift+ctrl+alt+] 整个文件函数展开</li>
<li>shift+ctrl+[ 单个函数折叠</li>
<li>shift+ctrl+] 单个函数展开</li>
</ul>
<ul>
<li>ctrl+[ 缩进</li>
<li>Ctrl+] 后退</li>
</ul>
<ul>
<li>Ctrl+I       选中一行</li>
<li>shift+ctrl+K 删除一行</li>
<li>ctrl+Enter   在当前行后插入一行</li>
</ul>
<ul>
<li>Ctrl+P       搜索最近打开的文档 alt+tab可以选择</li>
<li>Ctrl+T       在当前文件里查找符号</li>
<li>shift+ctrl+O 在工作空间里查找符号</li>
</ul>
<ul>
<li>按住Ctrl, 单击导航栏的文件名会显示在右侧</li>
</ul>
<ul>
<li>Ctrl+Down  鼠标位置不变，文件下移</li>
<li>Ctrl+Up       鼠标位置不变，文件上移</li>
</ul>
<ul>
<li>F3       向后查找</li>
<li>Shift+F3   向前查找</li>
</ul>
<ul>
<li>F1   显示所有命令</li>
</ul>
<ul>
<li>ctrl+click或F12 转到定义</li>
<li>ctrl+hover      显示定义或声明</li>
<li>shift+alt+F10   快速显示定义</li>
</ul>
<ul>
<li>ctrl+F2      高亮所有选中的单词</li>
<li>shift+ctrl+L 高亮所有选中的内容</li>
</ul>
<ul>
<li>shift+alt   multi select</li>
</ul>
<ul>
<li>自定义：</li>
<li>ctrl+left  后退</li>
<li>ctrl+right 前进</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cmd Markdown]]></title>
      <url>http://simmon.club/2016/06/30/2016-06-30-cmd-markdown/</url>
      <content type="html"><![CDATA[<p>Cmd Markdown是一种markdown文本编辑工具，这篇文章对该工具进行了相关的介绍。</p>
<a id="more"></a>
<h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>
<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"> </p>
<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>
<h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="external">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>
<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>
</blockquote>
<hr>
<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>
<h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="external">Todo 列表</a></h3><ul>
<li>[ ] 支持以 PDF 格式导出文稿</li>
<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li>[x] 新增 Todo 列表功能</li>
<li>[x] 修复 LaTex 公式渲染问题</li>
<li>[x] 新增 LaTex 公式编号功能</li>
</ul>
<h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>
<h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># A comment</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@requires_authorization</div><div class="line">class SomeClass:</div><div class="line">pass</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line"># A comment</div><div class="line">print &apos;hello world&apos;</div></pre></td></tr></table></figure>
<h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="external">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: Start</div><div class="line">op=&gt;operation: Your Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="external">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Alice-&gt;Bob: Hello Bob, how are you?</div><div class="line">Note right of Bob: Bob thinks</div><div class="line">Bob--&gt;Alice: I am good thanks!</div></pre></td></tr></table></figure>
<h3 id="6-绘制表格"><a href="#6-绘制表格" class="headerlink" title="6. 绘制表格"></a>6. 绘制表格</h3><table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">\$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">\$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">\$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="7-更详细语法说明"><a href="#7-更详细语法说明" class="headerlink" title="7. 更详细语法说明"></a>7. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="external">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="external">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>
<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>
<hr>
<h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>
<h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>
<h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p>
<h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右测的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>
<h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>
<h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>
<h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p>
<p>通过管理工具栏可以：</p>
<p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>
<h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p>
<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>
<p>工具栏上的五个图标依次为：</p>
<p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>
<h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>
<h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>
<p>标签： 未分类</p>
<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>
<p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p>
<h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>
<hr>
<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="external">@ghosert</a><br>2015 年 06月 15日    </p>
<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax</a> 参考更多使用方法。</p>
<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MongoDB的基本操作总结]]></title>
      <url>http://simmon.club/2016/02/17/2016-02-17-MongoDB-fundamentals/</url>
      <content type="html"><![CDATA[<p>这一部分主要总结一些MongoDB的基本用法。</p>
<a id="more"></a>
<ul>
<li><a href="http://www.runoob.com/mongodb/nosql.html" target="_blank" rel="external">NoSql简介</a></li>
<li><a href="http://www.runoob.com/mongodb/mongodb-intro.html" target="_blank" rel="external">MongoDB简介</a></li>
<li><a href="http://www.runoob.com/mongodb/mongodb-window-install.html" target="_blank" rel="external">在Windows平台下安装Mongo</a></li>
<li>[Mongo DB官方文档] (<a href="https://docs.mongodb.org/manual" target="_blank" rel="external">https://docs.mongodb.org/manual</a>)</li>
</ul>
<p>##MongoDB基本命令</p>
<ul>
<li>MongoDB的默认安装路径为 C:\Program Files\MongoDB</li>
<li>创建默认的数据库存放路径c:\data\db ,使用命令行把该路径关联到mongo上<br>C:\Program Files\MongoDB\Server\3.2\bin\mongod.exe –dbpath c:\data\db，执行成功后数据库服务开启并开始监听</li>
</ul>
<p>###Mongo Shell</p>
<ul>
<li>运行 C:\Program Files\MongoDB\Server\3.2\bin\mongod.exe 文件可以打开MongoDB Shell，它是一个自带的交互式的JavaScript shell，用来对MongoDB进行操作和管理的交互式环境</li>
<li>help 命令可以显示可使用的命令行</li>
</ul>
<h3 id="DB相关的操作"><a href="#DB相关的操作" class="headerlink" title="DB相关的操作"></a>DB相关的操作</h3><pre><code>use tutorial
</code></pre><p>使用该命令会尝试连接名字为tutorial的数据库，如果不存在则创建。使用db.help()命令可以查看命令行帮助</p>
<pre><code>show dbs
</code></pre><p>显示数据库的相关信息.</p>
<p>如果数据库相关的名字里包含了空格等字符，也可以用下面的命令</p>
<pre><code>db[&quot;dbname&quot;].find()
db.getCollection(&quot;dbname&quot;).find()
</code></pre><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>通过下面的格式来添加数据：</p>
<pre><code>db.restaurants.insert(
   {
      &quot;address&quot; : {
     &quot;street&quot; : &quot;2 Avenue&quot;,
     &quot;zipcode&quot; : &quot;10075&quot;,
     &quot;building&quot; : &quot;1480&quot;,
     &quot;coord&quot; : [ -73.9557413, 40.7720266 ],
  },
  &quot;borough&quot; : &quot;Manhattan&quot;,
  &quot;cuisine&quot; : &quot;Italian&quot;,
  &quot;grades&quot; : [
 {
    &quot;date&quot; : ISODate(&quot;2014-10-01T00:00:00Z&quot;),
    &quot;grade&quot; : &quot;A&quot;,
    &quot;score&quot; : 11
 },
 {
    &quot;date&quot; : ISODate(&quot;2014-01-16T00:00:00Z&quot;),
    &quot;grade&quot; : &quot;B&quot;,
    &quot;score&quot; : 17
 }
  ],
  &quot;name&quot; : &quot;Vella&quot;,
  &quot;restaurant_id&quot; : &quot;41704620&quot;
   }
)
</code></pre><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><p>如果想要查找所有的数据，则：</p>
<pre><code>db.collectionname.find()
</code></pre><p>指定条件：</p>
<p>指定field条件进行筛选，使用如下格式：</p>
<pre><code>{ &lt;field1&gt;: &lt;value1&gt;, &lt;field2&gt;: &lt;value2&gt;, ... }
</code></pre><p>具体的例子：</p>
<pre><code>db.restaurants.find( { &quot;borough&quot;: &quot;Manhattan&quot; } )
</code></pre><p>大于，小于条件的筛选</p>
<pre><code>db.restaurants.find( { &quot;grades.score&quot;: { $gt: 30 } } )
db.restaurants.find( { &quot;grades.score&quot;: { $lt: 10 } } )
</code></pre><p>AND和OR</p>
<pre><code>db.restaurants.find( { &quot;cuisine&quot;: &quot;Italian&quot;, &quot;address.zipcode&quot;: &quot;10075&quot; } )
db.restaurants.find( { $or: [ { &quot;cuisine&quot;: &quot;Italian&quot; }, { &quot;address.zipcode&quot;: &quot;10075&quot; } ] } )
</code></pre><p>排序</p>
<pre><code>db.restaurants.find().sort( { &quot;borough&quot;: 1, &quot;address.zipcode&quot;: 1 } )
</code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>下面的操作更新name为Juni的记录，用$set 操作来更新cuisine 字段。 用 $currentDate 操作符来更新lastModified字段：</p>
<pre><code>db.restaurants.update(
{ &quot;name&quot; : &quot;Juni&quot; },
{
  $set: { &quot;cuisine&quot;: &quot;American (New)&quot; },
  $currentDate: { &quot;lastModified&quot;: true }
}
)
</code></pre><p>更新内嵌的数据：</p>
<pre><code>db.restaurants.update(
  { &quot;restaurant_id&quot; : &quot;41156888&quot; },
  { $set: { &quot;address.street&quot;: &quot;East 31st Street&quot; } }
)
</code></pre><p>更新多条数据：<br>默认情况下update方法只更新一条数据。想要更新多条数据，使用multi option。</p>
<pre><code>db.restaurants.update(
  { &quot;address.zipcode&quot;: &quot;10016&quot;, cuisine: &quot;Other&quot; },
  {
    $set: { cuisine: &quot;Category To Be Determined&quot; },
    $currentDate: { &quot;lastModified&quot;: true }
  },
  { multi: true}
)
</code></pre><p>替换某条记录<br>根据某个_id字段的信息，用新的记录替换就得</p>
<pre><code>db.restaurants.update(
   { &quot;restaurant_id&quot; : &quot;41704620&quot; },
   {
     &quot;name&quot; : &quot;Vella 2&quot;,
     &quot;address&quot; : {
      &quot;coord&quot; : [ -73.9557413, 40.7720266 ],
      &quot;building&quot; : &quot;1480&quot;,
      &quot;street&quot; : &quot;2 Avenue&quot;,
      &quot;zipcode&quot; : &quot;10075&quot;
         }
   }
)
</code></pre><h3 id="删除某条记录"><a href="#删除某条记录" class="headerlink" title="删除某条记录"></a>删除某条记录</h3><p>删除符合某个条件的所有记录：</p>
<pre><code>db.restaurants.remove( { &quot;borough&quot;: &quot;Manhattan&quot; } )
</code></pre><p>只删除符合某个条件的一条记录，使用justOne选项：</p>
<pre><code>db.restaurants.remove( { &quot;borough&quot;: &quot;Queens&quot; }, { justOne: true } )
</code></pre><p>删除所有的记录：</p>
<pre><code>db.restaurants.remove( { } )
</code></pre><p>删除一个表：</p>
<pre><code>db.restaurants.drop()
</code></pre><h3 id="聚合运算"><a href="#聚合运算" class="headerlink" title="聚合运算"></a>聚合运算</h3><p>###聚合并累加</p>
<p>用$group 来通过某个关键字进行分组，在$group中，指定需要分组的关键字为_id。$group通过field path访问字段，字段名字需要以$为前缀。$sum表示累加器，下面的语句表示计算字段为borough的各种情况的个数。</p>
<pre><code>db.restaurants.aggregate(
   [
     { $group: { &quot;_id&quot;: &quot;$borough&quot;, &quot;count&quot;: { $sum: 1 } } }
   ]
);
</code></pre><p>输出结果为：</p>
<pre><code>{ &quot;_id&quot; : &quot;Staten Island&quot;, &quot;count&quot; : 969 }
{ &quot;_id&quot; : &quot;Brooklyn&quot;, &quot;count&quot; : 6086 }
{ &quot;_id&quot; : &quot;Manhattan&quot;, &quot;count&quot; : 10259 }
{ &quot;_id&quot; : &quot;Queens&quot;, &quot;count&quot; : 5656 }
{ &quot;_id&quot; : &quot;Bronx&quot;, &quot;count&quot; : 2338 }
{ &quot;_id&quot; : &quot;Missing&quot;, &quot;count&quot; : 51 }
</code></pre><h4 id="聚合并过滤"><a href="#聚合并过滤" class="headerlink" title="聚合并过滤"></a>聚合并过滤</h4><p>使用 $match 来过滤记录</p>
<pre><code>db.restaurants.aggregate(
   [
     { $match: { &quot;borough&quot;: &quot;Queens&quot;, &quot;cuisine&quot;: &quot;Brazilian&quot; } },
     { $group: { &quot;_id&quot;: &quot;$address.zipcode&quot; , &quot;count&quot;: { $sum: 1 } } }
   ]
);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法导论学习笔记 一 分治算法]]></title>
      <url>http://simmon.club/2016/02/17/2016-02-17-Algorithms-fundamentals-divideandconquer/</url>
      <content type="html"><![CDATA[<p>这一部分主要总结一些分制算法的基本思想。</p>
<a id="more"></a>
<p>分治策略是一种常见的算法。在分治策略中，我们递归的求解一个问题，在每层地柜中应用如下三个步骤：</p>
<ol>
<li>分解，将问题分解成规模更小但解决方案相同的子问题</li>
<li>解决，递归的求解子问题，如果子问题足够小则停止递归，直接求解</li>
<li>合并，将子问题的解组合成原问题的解</li>
</ol>
<h2 id="最大字数组问题"><a href="#最大字数组问题" class="headerlink" title="最大字数组问题"></a>最大字数组问题</h2><p>给你一段股市的波动图，找到在什么时候买入，什么时候卖出能获得最大的收益。</p>
<p><img src="http://i.imgur.com/K4HuEf4.jpg" alt=""></p>
<h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h3><p>我们很容易的想到一个包里破解法，就是把所有买入，卖出的组合列举出来进行对比，n天中取任意两天作为买入日和卖出日，共有n*(n-1)/2种解法，因此这种解法的时间复杂度是O(n^2）。</p>
<h3 id="问题变换"><a href="#问题变换" class="headerlink" title="问题变换"></a>问题变换</h3><p>为了方便我们处理，我们把每个数组的值变为股票的净增量。这个时候，最佳解法就变成了求一个数组的最大字数组：</p>
<p><img src="http://i.imgur.com/nT8zclC.jpg" alt=""></p>
<h3 id="使用分治策略的求解法"><a href="#使用分治策略的求解法" class="headerlink" title="使用分治策略的求解法"></a>使用分治策略的求解法</h3><p>我们可以认为，我们要寻找子数组array[start,end]的最大字数组分三种情况：</p>
<ul>
<li>最大字数组在左半部分</li>
<li>最大字数组在右半部分</li>
<li>最大字数组起点在左半部分，终点在右半部分</li>
</ul>
<p>对于前两种情况，我们的求解方式和分解前是相同的，我们需要单独处理第三种情况。</p>
<p>如图：</p>
<p><img src="http://i.imgur.com/mAJQJHb.jpg" alt=""></p>
<p>那么我们给出解这个问题的思路：</p>
<pre><code>FindMaxCrossingSubArray(array,start,end)
    mid=(start+end)/2
    从mid开始向左找，找到以mid为终点的最大字数组为array[max-left,min]
    从mid开始向右找，找到以mid为起点的最大字数组array[min,max-right]
    跨越mid的最大字数组为array[max-left,max-right]
    max-leftchild =FindMaxCrossingSubArray(array,start,mid)
    max-rightchild =FindMaxCrossingSubArray(array,min,end)
    return max-leftchild,max-rightchild,array[max-left,max-right] 3个中的最大字数组
</code></pre><h3 id="分治算法分析"><a href="#分治算法分析" class="headerlink" title="分治算法分析"></a>分治算法分析</h3><p>这种方法我们需要遍历的次数会比n^2少一些，时间复杂度为O(nlgn)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>自己尝试用C#实现了下，托管在了<a href="https://github.com/cuicheng11165/Algorithms" target="_blank" rel="external">github</a>上</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python模拟HttpRequest的方法总结]]></title>
      <url>http://simmon.club/2016/02/05/2016-02-05-Python-HttpRequest/</url>
      <content type="html"><![CDATA[<p>这一部分主要总结一些Python发送HttpRequest的相关API及其用法。</p>
<a id="more"></a>
<p>Python可以说是爬网的利器，本文主要介绍了一些python来模拟http请求的一些方法和技巧。</p>
<p>Python处理请求的类库有两个,urllib,urllib2。 这两个类库并不是一个类库的两个不同版本，urllib主要用来处理一些url相关的内容，发送请求的时候，请求对象只能是一个url。urllib2可以用request对象来实现请求，这样就可以实现如伪造头部，设置代理，http get，http post等方法。</p>
<p>阅读本文需要了解http请求的一些基本知识，如：</p>
<ul>
<li>什么是httpwebrequest，httpwebresponse</li>
<li>什么是get，post</li>
<li>什么是cookie</li>
</ul>
<p>本文主要介绍模拟请求用到的这些方式：</p>
<ul>
<li>设置代理</li>
<li>伪造头部或者Header信息</li>
<li>启用cookie</li>
<li>url参数的处理</li>
</ul>
<h3 id="使用urllib2-urlopen直接发送"><a href="#使用urllib2-urlopen直接发送" class="headerlink" title="使用urllib2.urlopen直接发送"></a>使用urllib2.urlopen直接发送</h3><pre><code>import urllib2

url = &apos;http://www.baidu.com/&apos;
response = urllib2.urlopen(url) ##urlopen接受传入参数是string或者是request
response_text = response.read()
</code></pre><h3 id="使用urllib-build-opener"><a href="#使用urllib-build-opener" class="headerlink" title="使用urllib.build_opener"></a>使用urllib.build_opener</h3><h4 id="直接发送请求"><a href="#直接发送请求" class="headerlink" title="直接发送请求"></a>直接发送请求</h4><pre><code>import urllib2

url = &apos;http://www.baidu.com/&apos;

opener = urllib2.build_opener()
response = opener.open(url)
response_text = response.read()
</code></pre><h4 id="通过代理访问站点"><a href="#通过代理访问站点" class="headerlink" title="通过代理访问站点"></a>通过代理访问站点</h4><pre><code>proxy_handler = urllib2.ProxyHandler({&quot;http&quot; : &apos;http://localhost:8888&apos;})
opener = urllib2.build_opener(proxy_handler)
response = opener.open(url)
response_text = response.read()
</code></pre><h4 id="请求中附带request-body-http-post"><a href="#请求中附带request-body-http-post" class="headerlink" title="请求中附带request body(http post)"></a>请求中附带request body(http post)</h4><pre><code>opener = urllib2.build_opener()
response = opener.open(url,&apos;request body&apos;)
response_text = response.read()
</code></pre><p>body中如果是key-value形式的，可以参照下面的url处理部分来处理</p>
<h4 id="启用Cookie"><a href="#启用Cookie" class="headerlink" title="启用Cookie"></a>启用Cookie</h4><pre><code>cookie = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))
response = opener.open(url)
response_text = response.read()
</code></pre><h3 id="使用urllib2-Request"><a href="#使用urllib2-Request" class="headerlink" title="使用urllib2.Request"></a>使用urllib2.Request</h3><h4 id="请求中添加自定义的Header信息"><a href="#请求中添加自定义的Header信息" class="headerlink" title="请求中添加自定义的Header信息"></a>请求中添加自定义的Header信息</h4><pre><code>request = urllib2.Request(url)
request.add_data(&apos;1234567&apos;)
request.add_header(&apos;User-Agent&apos;, &apos;fake-client&apos;)
response = urllib2.urlopen(request)
</code></pre><h3 id="处理url中的参数信息"><a href="#处理url中的参数信息" class="headerlink" title="处理url中的参数信息"></a>处理url中的参数信息</h3><p>无论是使用get方式还是post方式，经常会遇到需要使用参数的形式，处理参数可以使用下面的类库</p>
<h4 id="参数集合转string"><a href="#参数集合转string" class="headerlink" title="参数集合转string"></a>参数集合转string</h4><pre><code>para = {&apos;111&apos;:&apos;222&apos;,&apos;aaa&apos;:&apos;bbb&apos;}
encodeurl = urllib.urlencode(para)
输出aaa=bbb&amp;111=222
</code></pre><h4 id="url参数转dictionary"><a href="#url参数转dictionary" class="headerlink" title="url参数转dictionary"></a>url参数转dictionary</h4><pre><code>url = &apos;https://www.baidu.com/s?wd=python%20url%20querystring&amp;pn=10&amp;oq=python%20url%20querystring&amp;tn=baiduhome_pg&amp;ie=utf-8&amp;usm=1&amp;rsv_idx=2&amp;rsv_pq=d09af93600035cb8&amp;rsv_t=d151qRmNNdybGINHcKbyO360E2%2Fg%2FUs2t0MiKqRQXwhHZuNF3IlKyyStzYuofVZczQA3&apos;

splitresult_instance = urlparse.urlsplit(url)
</code></pre><p>输出对象：<br>SplitResult(scheme=’https’, netloc=’www.baidu.com’, path=’/s’, query=’wd=python%20url%20querystring&amp;pn=10&amp;oq=python%20url%20querystring&amp;tn=baiduhome_pg&amp;ie=utf-8&amp;usm=1&amp;rsv_idx=2&amp;rsv_pq=d09af93600035cb8&amp;rsv_t=d151qRmNNdybGINHcKbyO360E2%2Fg%2FUs2t0MiKqRQXwhHZuNF3IlKyyStzYuofVZczQA3’, fragment=’’)</p>
<p>想转成集合只要</p>
<pre><code>result_dic=urlparse.parse_qs(splitresult.query)
</code></pre><p>通过这种处理方式，把data信息放在url上来实现http get，放在body中实现http post。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[.NET线程池的介绍]]></title>
      <url>http://simmon.club/2016/02/04/2016-02-04-getstarted-threadpool/</url>
      <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>当你创建一个新的线程的时候，大概需要几百微秒的时间来构建一个新的私有变量堆栈，1M的用户模式堆栈，加载一些必要的DLL。无论如何创建一个线程都是一个浪费资源的行为，线程池就是为了通过线程的重用来避免线程重建的开销。</p>
<p>当CLR初始化的时候，线程池里没有线程。线程池内部会维护一个请求队列，当你的程序想执行异步操作的时候，你调用的方法会请求线程池的资源进入请求队列。如果线程池没有线程，线程池会创建新的线程，当任务结束的时候，线程不会马上被销毁，而是变为闲置状态，一段时间后，会自动结束。这样避免了频繁创建销毁线程带来的开销。</p>
<p>有以下几种方式来进行线程池的操作:</p>
<ul>
<li>通过Task Parallel Library（TPL），在Framework 4.0开始支持</li>
<li>通过调用ThreadPool.QueueUserWorkItem</li>
<li>通过异步委托</li>
<li>通过 BackgroundWorker</li>
</ul>
<h3 id="通过TPL来使用线程池"><a href="#通过TPL来使用线程池" class="headerlink" title="通过TPL来使用线程池"></a>通过TPL来使用线程池</h3><p>.NET Frameworkd 4.0 中引入了<strong>Task</strong>来访问线程池，可以说是ThreadPool.QueueUserWorkItem的升级版，泛型的Task&lt;TResult&gt;是匿名委托方式的升级版。新的Task可以更方便灵活的使用线程池。<br>你可以使用如下方式来使用Task： </p>
<pre><code>static void Main()// The Task class is in System.Threading.Tasks
{
  Task.Factory.StartNew (Go);
}

static void Go()
{
  Console.WriteLine (&quot;Hello from the thread pool!&quot;);
}
</code></pre><p>Task&lt;TResult&gt; 是一个泛型版的Task： </p>
<pre><code>static void Main()
{
  // Start the task executing:
  Task&lt;string&gt; task = Task.Factory.StartNew&lt;string&gt;
( () =&gt; DownloadString (&quot;http://www.linqpad.net&quot;) );

  // We can do other work here and it will execute in parallel:
  RunSomeOtherMethod();

  // When we need the task&apos;s return value, we query its Result property:
  // If it&apos;s still executing, the current thread will now block (wait)
  // until the task finishes:
  string result = task.Result;
}

static string DownloadString (string uri)
{
  using (var wc = new System.Net.WebClient())
return wc.DownloadString (uri);
}
</code></pre><h3 id="使用ThreadPool来访问线程池"><a href="#使用ThreadPool来访问线程池" class="headerlink" title="使用ThreadPool来访问线程池"></a>使用ThreadPool来访问线程池</h3><p>使用QueueUserWorkItem可以简单的通过线程池来执行一个委托：<br>    static void Main()<br>    {<br>      ThreadPool.QueueUserWorkItem (Go);<br>      ThreadPool.QueueUserWorkItem (Go, 123);<br>      Console.ReadLine();<br>    }</p>
<pre><code>static void Go (object data)   // data will be null with the first call.
{
  Console.WriteLine (&quot;Hello from the thread pool! &quot; + data);
}
</code></pre><h3 id="异步委托来访问线程池"><a href="#异步委托来访问线程池" class="headerlink" title="异步委托来访问线程池"></a>异步委托来访问线程池</h3><p>通过异步委托来执行线程需要以下几步：</p>
<ol>
<li>初始化一个委托</li>
<li>调用BeginInvoke，获得一个IAsyncResult返回值</li>
<li>当你需要异步委托的返回值时，调用EndInvoke，传入上一步返回的IAsyncResult</li>
</ol>
<p>示例代码：</p>
<pre><code>static void Main()
{
  Func&lt;string, int&gt; method = Work;
  IAsyncResult cookie = method.BeginInvoke (&quot;test&quot;, null, null);
  //
  // ... here&apos;s where we can do other work in parallel...
  //
  int result = method.EndInvoke (cookie);
  Console.WriteLine (&quot;String length is: &quot; + result);
}

static int Work (string s) { return s.Length; }
</code></pre><p>上面的例子，当执行委托结束时，也可以指定一个回调方法来通知调用者：</p>
<pre><code>static void Main()
{
  Func&lt;string, int&gt; method = Work;
  method.BeginInvoke (&quot;test&quot;, Done, method);
  // ...
  //
}

static int Work (string s) { return s.Length; }

static void Done (IAsyncResult cookie)
{
  var target = (Func&lt;string, int&gt;) cookie.AsyncState;
  int result = target.EndInvoke (cookie);
  Console.WriteLine (&quot;String length is: &quot; + result);
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git Shell 基本命令(官网脱水版)]]></title>
      <url>http://simmon.club/2016/02/03/2016-02-02-git-cmd-instruction/</url>
      <content type="html"><![CDATA[<h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：  </p>
<p>$ <strong>git config –global user.name “John Doe”</strong><br>$ <strong>git config –global user.email johndoe@example.com</strong></p>
<h2 id="获取命令帮助"><a href="#获取命令帮助" class="headerlink" title="获取命令帮助"></a>获取命令帮助</h2><p>$ <strong>git help verb</strong><br>$ <strong>git verb help</strong><br>$ <strong>man git-verb</strong>  </p>
<h2 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h2><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。</p>
<h2 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h2><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录(本地路径)并输入：<br>$ <strong>git init</strong></p>
<p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交： </p>
<p>$ <strong>git add *</strong><br>$ <strong>git add LICENSE</strong><br>$ <strong>git commit -m ‘initial project version’</strong></p>
<h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>如果你想下载托管在git上的代码，只需要知道代码托管路径，然后输入：<br>$ <strong>git clone <a href="https://github.com/libgit2/libgit2" target="_blank" rel="external">https://github.com/libgit2/libgit2</a></strong><br>如果你想重命名下载到本地的目录那么输入：<br>$ <strong>git clone <a href="https://github.com/libgit2/libgit2" target="_blank" rel="external">https://github.com/libgit2/libgit2</a> foldername</strong><br>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 foldername。</p>
<h2 id="记录每次更新"><a href="#记录每次更新" class="headerlink" title="记录每次更新"></a>记录每次更新</h2><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要查看哪些文件处于什么状态，可以用 git status 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：  </p>
<p>$ <strong>git status</strong>    </p>
<p>现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件：  </p>
<p>$ <strong>echo ‘Readme文件内容’ &gt; README</strong><br>$ <strong>git status</strong></p>
<p>使用这个命令你会看到哪些文件没有被版本库记录了。</p>
<h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>把刚刚创建的README放入版本库中跟踪，只需要：<br>$ <strong>git add README</strong><br>$ <strong>git status</strong></p>
<h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p>$ <strong>git status -s</strong><br>　M README<br>MM Rakefile<br>A　 lib/git.rb<br>M　 lib/simplegit.rb<br>??　LICENSE.txt<br>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 来看一个实际的例子：</p>
<p>$ <strong>cat .gitignore</strong><br>这个命令表示读取.gitignore文件下的内容，并输出到控制台上</p>
<h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <strong>git diff</strong><br>若要查看已暂存的将要添加到下次提交里的内容，可以用 <strong>git diff –cached</strong> 命令</p>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>提交更新之前，git status看下所有修改是否都被记录了，然后<br>$ <strong>git commit</strong></p>
<p>可能会进入vim模式，这时候 ctrl+c 输入 :wq  保存文件并退出，也可以</p>
<p>$ <strong>git commit -m “Story 182: Fix benchmarks for speed”</strong></p>
<h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>正常的提交流程是:  </p>
<ul>
<li><strong>git status</strong> 查看状态  </li>
<li><strong>git add .</strong> 放入暂存区域  </li>
<li><strong>git commit -m “提交记录”</strong>  </li>
</ul>
<p>来提交，如果你觉得这样太麻烦，可以-a来跳过暂存区域：<br>$ <strong>git commit -a -m ‘added new benchmarks’</strong></p>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>移除文件分两种，是否在当前目录保留这个文件，需要保留则：<br>$ <strong>git rm –cached filename</strong><br>不需要保留则：<br>$ <strong>git rm filename</strong></p>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>$ <strong>git log</strong><br>即可。至于更高端的用法，查看<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="external">文档</a></p>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>类似于svn的revert操作：<br>$ <strong>git checkout – filename.md</strong><br>$ <strong>git status</strong></p>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><ul>
<li><p>新代码publish到新的仓库<br>如果你想把你的没有被git托管的代码发布到github上，那么按照下面的操作：<br><strong>echo “readme文件内容” &gt;&gt; README.md</strong><br><strong>git init</strong><br><strong>git add README.md</strong><br><strong>git commit -m “first commit”</strong><br><strong>git remote add origin <a href="https://github.com/cuicheng11165/1758.git" target="_blank" rel="external">https://github.com/cuicheng11165/1758.git</a></strong><br><strong>git push -u origin master</strong>  </p>
</li>
<li><p>现有仓库发布到远程仓库<br>如果git已经在本地托管了，那么只需要：<br><strong>git remote add origin <a href="https://github.com/cuicheng11165/1758.git" target="_blank" rel="external">https://github.com/cuicheng11165/1758.git</a></strong><br><strong>git push -u origin master</strong>  </p>
</li>
</ul>
<p>拉取远程的改动分为pull 和fetch，pull相当于fetch+merge  </p>
<ul>
<li>fetch的使用：<br><strong>git fetch origin master</strong><br><strong>git merge</strong>  </li>
<li>pull的使用:<br><strong>git pull origin master</strong>  </li>
</ul>
<p>##git submodule</p>
<p>在一个Github资源中引用另一个github资源，可以通过子模块来实现。<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="external">文档</a></p>
<p><strong>git submodule add <a href="https://github.com/chaconinc/DbConnector" target="_blank" rel="external">https://github.com/chaconinc/DbConnector</a></strong></p>
<p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">官方文档</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Github上搭建自己的博客(Windows平台)]]></title>
      <url>http://simmon.club/2016/02/02/2016-02-02-publish-blog-to-github/</url>
      <content type="html"><![CDATA[<p>折腾了好久，终于在Github上搭建了自己的博客。这里面总结一下过程希望对大家能有所帮助。</p>
<h2 id="Github建博优缺点"><a href="#Github建博优缺点" class="headerlink" title="Github建博优缺点"></a>Github建博优缺点</h2><ul>
<li>和 csdn，博客园，网易相比，在Github上可以自己实现功能，跳过运营商的限制  </li>
<li>和阿里云，VPS相比，github托管的代码是免费的  </li>
<li>github上只能托管静态网页，后台有数据库的这种动态网站不能托管  </li>
</ul>
<h2 id="你有一个Github的账号"><a href="#你有一个Github的账号" class="headerlink" title="你有一个Github的账号"></a>你有一个Github的账号</h2><ul>
<li>懂一些基本的Web开发相关的知识  </li>
<li>Ruby运行时，可以在Windows或者linux环境下进行安装  </li>
</ul>
<h2 id="建站的过程"><a href="#建站的过程" class="headerlink" title="建站的过程"></a>建站的过程</h2><ul>
<li>在github创建网站的代码库，名字必须为username.github.io格式  </li>
<li>将你的网站的代码上传到代码库中  </li>
<li>配置域名  </li>
</ul>
<p>如果你每一次写博客的同时还要手写html css 等信息，那么工作量会很大，github支持jekyll来自动生成页面。</p>
<h2 id="Jekyll环境的搭建"><a href="#Jekyll环境的搭建" class="headerlink" title="Jekyll环境的搭建"></a>Jekyll环境的搭建</h2><ul>
<li>如果你是在Windows环境下配置。首先需要安装Ruby运行时，Jekyll是一个用Ruby写的软件。<br><a href="http://jekyll-windows.juthilo.com/" target="_blank" rel="external">Run Jekyll On Windows</a>  里面展示了Windows下使用Jekyll的方法，大体分以下几步完成：</li>
</ul>
<ol>
<li>安装Ruby运行时，<a href="http://rubyinstaller.org/downloads/" target="_blank" rel="external">下载地址</a> ,windows 平台下的安装过程很简单，安装过程记得勾选Add Ruby excuteables to  your PATH</li>
<li>安装RubyDevKi，和Ruby的版本相同。下载后解压,执行以下3步：<br>cd c:\RubyDevki<br>ruby dk.rb init<br>ruby dk.rb install  </li>
<li>安装jekyll，github上给出了配置文档 <a href="https://help.github.com/articles/using-jekyll-with-pages" target="_blank" rel="external">install Jekyll</a> ，Bundler是一个包管理器，让你更方便的使用Ruby里面的软件，如果你想要在本地编译Github页面，那么使用 gem install bundler 来安装bundler</li>
<li>配置jekyll,在站点的根目录里创建一个文件 Gemfile,文件内容如下：<br>source ‘<a href="https://rubygems.org" target="_blank" rel="external">https://rubygems.org</a>‘<br>gem ‘github-pages’<br>然后运行bundle install即可安装Jekyll。  </li>
<li>安装成功后，运行 jekyll newe sitename 即可创建一个站点</li>
<li>命令行 bundle exec jekyll serve即可运行站点，成功后访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 即可。</li>
</ol>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p>买一个域名，把域名的ip指向github服务器，在网站的目录下建一个文件名为CNAME，文件的内容是你的域名，提交。购买的域名就会指向你的博客。</p>
<h2 id="Jekyll网站的定制"><a href="#Jekyll网站的定制" class="headerlink" title="Jekyll网站的定制"></a>Jekyll网站的定制</h2><p>网站的语言是基于liquid的，每一次你修改文件后，jekyll会自动重新生成网站。编辑成功后提交到github，访问<a href="http://username.github.io" target="_blank" rel="external">http://username.github.io</a> 访问你的博客。这里面有一些别人共享的网站模板可以供大家选择。<a href="http://jekyllthemes.org/" target="_blank" rel="external">网站模板</a>里面有很多别人共享的主题。</p>
<h2 id="Jekyll网站需要解决的一些问题"><a href="#Jekyll网站需要解决的一些问题" class="headerlink" title="Jekyll网站需要解决的一些问题"></a>Jekyll网站需要解决的一些问题</h2><ol>
<li>网站是静态的，因此只需要发表博客重新生成即可，发表博客可以使用 <a href="https://en.wikipedia.org/wiki/Markdown" target="_blank" rel="external">markdown</a> 来实现，简化了写博客的过程</li>
<li>网站的社交功能需要想办法实现，因为没有后台数据库，因此需要一些第三方的帮助来实现留言回复功能。常用的有多说，disqus等</li>
<li>现有模板有很多的前台是基于<a href="http://baike.baidu.com/link?url=_Ju_TPVJCSducO4xSr6TwL5Bx5ZDRhK9bvpTzC8_wgKVVfNA2VZtpWdMk04nL7cixReciDCO1C0o-w76AD7GqxqVLggXiQTW_46OF7HkNWC" target="_blank" rel="external">bootstrap</a>来实现的，里面一些脚本的信息可能会被墙，需要自己找替代</li>
</ol>
<h2 id="编写博客"><a href="#编写博客" class="headerlink" title="编写博客"></a>编写博客</h2><p>博客的编写一般是基于markdown来实现的，markdown本身是为了简化书写的设计的<a href="https://en.wikipedia.org/wiki/Markdown#Example" target="_blank" rel="external">语法</a>，大家不用写博客的时候还考虑html语法，关于markdown的编译，windows平台下推荐使用markdownpad，可以编辑markdown的同时进行preview，非常的方便。</p>
<p>参考文章：<br><a href="http://jekyll-windows.juthilo.com" target="_blank" rel="external">如何在Windows下使用Jekyll</a><br><a href="http://www.pchou.info/web-build/2013/01/03/build-github-blog-page-01.html" target="_blank" rel="external">一步一步在Github上创建主页</a><br><a href="http://www.williamlong.info/archives/4319.html" target="_blank" rel="external">好用的Markdown编辑器一览</a><br><a href="https://en.wikipedia.org/wiki/Markdown" target="_blank" rel="external">Markdown Wiki</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[带你看懂Dictionary内部实现]]></title>
      <url>http://simmon.club/2016/02/02/2015-12-16-inside-dictionary/</url>
      <content type="html"><![CDATA[<p>主要总结一些C# Dictionary的内部工作机制。</p>
<a id="more"></a>
<p>&nbsp;</p><br><p>了解Dictionary的开发人员都了解，和List相比，字典添加会慢，但是查找会比较快，那么Dictionary是如何实现的呢？</p><br><h1>Dictionary的构造</h1><br><p>下面的代码我看看Dictionary在构造时都做了什么：</p><br><div class="cnblogs_code"><br><pre>        <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> Initialize(<span style="color: #0000ff;">int</span><span style="color: #000000;"> capacity)<br>        {<br>            </span><span style="color: #0000ff;">int</span> prime =<span style="color: #000000;"> HashHelpers.GetPrime(capacity);<br>            </span><span style="color: #0000ff;">this</span>.buckets = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">[prime];<br>            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #0000ff;">this</span>.buckets.Length; i++<span style="color: #000000;">)<br>            {<br>                </span><span style="color: #0000ff;">this</span>.buckets[i] = -<span style="color: #800080;">1</span><span style="color: #000000;">;<br>            }<br>            </span><span style="color: #0000ff;">this</span>.entries = <span style="color: #0000ff;">new</span> Entry&lt;TKey, TValue&gt;<span style="color: #000000;">[prime];<br>            </span><span style="color: #0000ff;">this</span>.freeList = -<span style="color: #800080;">1</span><span style="color: #000000;">;<br>        } </span></pre><br></div><br><p>&nbsp;</p><br><p>我们看到，Dictionary在构造的时候做了以下几件事：</p><br><ol style="margin-left: 54pt;"><br><li>初始化一个this.buckets = new int[prime]</li><br><li>初始化一个this.entries = new Entry&lt;TKey, TValue&gt;[prime]</li><br><li>Bucket和entries的容量都为大于字典容量的一个最小的质数</li><br></ol><br><p>其中this.buckets主要用来进行Hash碰撞，this.entries用来存储字典的内容，并且标识下一个元素的位置。</p><br><p>我们以Dictionary&lt;int,string&gt; 为例，来展示一下Dictionary如何添加元素：</p><br><p>首先，我们构造一个:</p><br><p>Dictionary&lt;int, string&gt; test = new Dictionary&lt;int, string&gt;(6);</p><br><h1>初始化后<span style="font-size: 11pt;">： </span></h1><br><p><img src="http://images0.cnblogs.com/blog/147759/201507/220046159287455.png" alt=""></p><br><h1>添加元素时，集合内部Bucket和entries的变化</h1><br><h2>Test.Add(4,”4”)后：</h2><br><p>根据Hash算法： 4.GetHashCode()%7= 4,因此碰撞到buckets中下标为4的槽上，此时由于Count为0，因此元素放在Entries中第0个元素上，添加后Count变为1</p><br><p><img src="http://images0.cnblogs.com/blog/147759/201507/220046164126140.png" alt=""></p><br><p>&nbsp;</p><br><p>&nbsp;</p><br><h2>Test.Add(11,”11”)</h2><br><p>根据Hash算法 11.GetHashCode()%7=4,因此再次碰撞到Buckets中下标为4的槽上，由于此槽上的值已经不为-1，此时Count=1，因此把这个新加的元素放到entries中下标为1的数组中，并且让Buckets槽指向下标为1的entries中，下标为1的entry之下下标为0的entries。</p><br><p><img src="http://images0.cnblogs.com/blog/147759/201507/220046169594040.png" alt=""></p><br><h2>Test.Add(18,”18”)</h2><br><p>我们添加18，让HashCode再次碰撞到Buckets中下标为4的槽上，这个时候新元素添加到count+1的位置，并且Bucket槽指向新元素，新元素的Next指向Entries中下标为1的元素。此时你会发现所有hashcode相同的元素都形成了一个链表，如果元素碰撞次数越多，链表越长。所花费的时间也相对较多。</p><br><p>&nbsp;</p><br><p><img src="http://images0.cnblogs.com/blog/147759/201507/220046174907710.png" alt=""></p><br><h2>Test.Add(19,”19”)</h2><br><p>再次添加元素19，此时Hash碰撞到另外一个槽上，但是元素仍然添加到count+1的位置。</p><br><p><img src="http://images0.cnblogs.com/blog/147759/201507/220046181316582.png" alt=""></p><br><p>&nbsp;</p><br><p>&nbsp;</p><br><h2>删除元素时集合内部的变化</h2><br><h2>Test.Remove(4)</h2><br><p>我们删除元素时，通过一次碰撞，并且沿着链表寻找3次，找到key为4的元素所在的位置，删除当前元素。并且把FreeList的位置指向当前删除元素的位置，FreeCount置为1</p><br><p><img src="http://images0.cnblogs.com/blog/147759/201507/220046192098152.png" alt=""></p><br><p>&nbsp;</p><br><h2>Test.Remove(18)</h2><br><p>删除Key为18的元素，仍然通过一次碰撞，并且沿着链表寻找2次，找到当前元素，删除当前元素，并且让FreeList指向当前元素，当前元素的Next指向上一个FreeList元素。</p><br><p>此时你会发现FreeList指向了一个链表，链表里面不包含任何元素，FreeCount表示不包含元素的链表的长度。</p><br><p><img src="http://images0.cnblogs.com/blog/147759/201507/220046201463766.png" alt=""></p><br><h2>Test.Add(20,”20”)</h2><br><p>再添加一个元素，此时由于FreeList链表不为空，因此字典会优先添加到FreeList链表所指向的位置，添加后FreeCount减1，FreeList链表长度变为1</p><br><p><img src="http://images0.cnblogs.com/blog/147759/201507/220046208035866.png" alt=""></p><br><h1>总结：</h1><br><p>通过以上试验，我们可以发现Dictionary在添加，删除元素按照如下方法进行：</p><br><ol><br><li>通过Hash算法来碰撞到指定的Bucket上，碰撞到同一个Bucket槽上所有数据形成一个单链表</li><br><li>默认情况Entries槽中的数据按照添加顺序排列</li><br><li>删除的数据会形成一个FreeList的链表，添加数据的时候，优先向FreeList链表中添加数据，FreeList为空则按照count依次排列</li><br><li>字典查询及其的效率取决于碰撞的次数，这也解释了为什么Dictionary的查找会很快。</li><br></ol><br><p>&nbsp;</p><br><p>好吧，熬了半宿，今天先写到这了，如果看了有所收获就帮忙顶一下，有问题欢迎拍砖。</p><br><p>&nbsp;</p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Fiddler Core 来测试你的Web API]]></title>
      <url>http://simmon.club/2015/12/15/2015-12-15-fiddler-core-test-webapi/</url>
      <content type="html"><![CDATA[<p>大家在调试Web相关的API时，经常会用Fiddler来查看相关的请求，以及返回结果。当然你也可以尝试修改或者重复你的请求信息。本文主要介绍如何使用代码来实现fiddler的功能。</p><br><h2>Fiddler Core API</h2><br><p>Fiddler Core几乎实现了你能用fiddler做的所有功能。直接在NuGet上搜索FiddlerCore即可下载FiddlerCore的.Net API。</p><br><p><img src="http://images2015.cnblogs.com/blog/147759/201512/147759-20151213123051262-2134426614.png" alt=""></p><br><h2>开启Fiddler Application</h2><br><p>使用下面的代码来开启FiddlerApplication</p><br><p><span style="color: #2b91af; font-family: Consolas; font-size: 9pt;"><span style="background-color: white;">FiddlerApplication<span style="color: black;">.Startup(9898, <span style="color: #2b91af;">FiddlerCoreStartupFlags<span style="color: black;">.Default);</span></span></span></span> </span></p><br><p>执行后，fiddler会运行一个http代理服务器，你可以使用FiddlerCoreStartupFlags.RegisterAsSystemProxy 来把这个代理服务器指定为系统代理，这样就可以监听到本机所有的http请求。</p><br><p>当程序结束的时候，记得使用下面的语句来关闭代理。</p><br><p><span style="color: #2b91af; font-family: Consolas; font-size: 9pt;"><span style="background-color: white;">FiddlerApplication<span style="color: black;">.Shutdown();</span></span> </span></p><br><h2>捕获HttpRequest/HttpResponse</h2><br><p>开启了Fiddler Application之后，Fiddler在捕获Request/Response的时候会触发下面这两个事件，你只需要定义事件来实现如何处理捕获到的请求即可。</p><br><p><span style="color: black; font-family: Consolas; font-size: 9pt; background-color: white;"> <span style="color: green;">//</span></span></p><br><p><span style="color: black; font-family: Consolas; font-size: 9pt; background-color: white;"> <span style="color: green;">// Summary:</span></span></p><br><p><span style="color: black; font-family: Consolas; font-size: 9pt; background-color: white;"> <span style="color: green;">// This event fires when a client request is received by Fiddler</span></span></p><br><p><span style="color: black; font-family: Consolas; font-size: 9pt; background-color: white;"> <span style="color: blue;">public<span style="color: black;"> <span style="color: blue;">static<span style="color: black;"> <span style="color: blue;">event<span style="color: black;"> <span style="color: #2b91af;">SessionStateHandler<span style="color: black;"> BeforeRequest; </span></span></span></span></span></span></span></span></span></p><br><p><span style="color: black; font-family: Consolas; font-size: 9pt; background-color: white;"> <span style="color: green;">//</span></span></p><br><p><span style="color: black; font-family: Consolas; font-size: 9pt; background-color: white;"> <span style="color: green;">// Summary:</span></span></p><br><p><span style="color: black; font-family: Consolas; font-size: 9pt; background-color: white;"> <span style="color: green;">// This event fires when a server response is received by Fiddler</span></span></p><br><p><span style="color: black; font-family: Consolas; font-size: 9pt;"><span style="background-color: white;"> <span style="color: blue;">public<span style="color: black;"> <span style="color: blue;">static<span style="color: black;"> <span style="color: blue;">event<span style="color: black;"> <span style="color: #2b91af;">SessionStateHandler<span style="color: black;"> BeforeResponse;</span></span></span></span></span></span></span></span></span> </span></p><br><h2>安装证书</h2><br><p>那么如何捕获https协议的页面呢？众所周知，https通过通信证书来实现了服务器端和客户端的加密，避免通信过程被监听。Fiddler通过中间人的方式来实现https协议的捕获，所谓中间人就是Fiddler注入到应用程序和服务器的中间，fiddler相对于服务器扮演客户端的角色，相对于客户端扮演服务器的角色，既然fiddler需要扮演服务器的角色，就需要一个证书，并且你的客户端需要信任Fiddler的证书。我们以中国银行的网站为例：</p><br><p>不开启Fiddler登陆网银时，证书信息为：</p><br><p><img src="http://images2015.cnblogs.com/blog/147759/201512/147759-20151213123051919-1844797516.png" alt=""></p><br><p>&nbsp;</p><br><p>开启Fiddler登陆网银后证书信息为：</p><br><p><img src="http://images2015.cnblogs.com/blog/147759/201512/147759-20151213123052637-506067430.png" alt=""></p><br><p>由于我的机器已经信任过Fiddler的证书，我们可以发现，在开启了Fiddler后，和中行网银的通信证书变为了：DO_NOT_TRUST_FiddlerRoot。如果使用FiddlerCore，我们同样需要信任这个证书，相关的代码如下：</p><br><div class="cnblogs_Highlighter"><br><pre class="brush:csharp;gutter:true;">public static bool InstallCertificate()<br>{<br>    if (!CertMaker.rootCertExists())<br>    {<br>        if (!CertMaker.createRootCert())<br>            return false;<br><br>        if (!CertMaker.trustRootCert())<br>            return false;<br>    }<br><br>    return true;<br>}</pre><br></div><br><h2>开始捕获</h2><br><p>使用这种方式，可以在不改变你现有代码的情况下，测试你的API返回结果是否正确。下面的例子是一个用FiddlerCoreAPI来测试SharePointOnline认证是否通过的例子。</p><br><div class="cnblogs_Highlighter"><br><pre class="brush:csharp;gutter:true;">using Fiddler;<br>using Microsoft.SharePoint.Client;<br>using System;<br>using System.Collections.Generic;<br>using System.IO;<br>using System.Linq;<br>using System.Net;<br>using System.Security;<br>using System.Text;<br>using System.Threading.Tasks;<br><br>namespace FiddlerCoreTest<br>{<br>    class Program<br>    {<br>        static void Main(string[] args)<br>        {<br>            ServicePointManager.ServerCertificateValidationCallback = (a, b, c, d) =&gt; true;<br><br>            FiddlerApplication.BeforeRequest += FiddlerApplication_BeforeRequest;<br>            FiddlerApplication.BeforeResponse += FiddlerApplication_BeforeResponse;<br>            FiddlerApplication.Startup(9898, FiddlerCoreStartupFlags.Default | FiddlerCoreStartupFlags.RegisterAsSystemProxy);<br>            try<br>            {<br>                ClientContext context = new ClientContext(“<a href="https://domain.sharepoint.com" target="_blank" rel="external">https://domain.sharepoint.com</a>“);<br><br>                SecureString se = new SecureString();<br>                foreach (var cc in “password”)<br>                {<br>                    se.AppendChar(cc);<br>                }<br><br>                var cre = new SharePointOnlineCredentials(“user@domain.onmicrosoft.com”, se);<br>                var cookie = cre.GetAuthenticationCookie(new Uri(“<a href="https://domain.sharepoint.com" target="_blank" rel="external">https://domain.sharepoint.com</a>“));<br>            }<br>            catch (Exception e)<br>            {<br><br>            }<br><br>            FiddlerApplication.Shutdown();<br>            Console.ReadLine();<br>        }<br><br>        static void FiddlerApplication_BeforeResponse(Session oSession)<br>        {<br>            //想如何改写Response信息在这里随意发挥了<br>            Console.WriteLine(“BeforeResponse: {0}”, oSession.responseCode);<br>        }<br><br>        static void FiddlerApplication_BeforeRequest(Session oSession)<br>        {<br>            //想如何改写Request信息在这里随意发挥了<br>            Console.WriteLine(“BeforeRequest: {0}, {1}”, oSession.fullUrl, oSession.responseCode);<br>        }<br>    }<br>}<br></pre><br></div><br><p>　　</p>
]]></content>
    </entry>
    
  
  
</search>
